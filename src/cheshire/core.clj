(ns cheshire.core
  "Main encoding and decoding namespace."
  (:require [cheshire.factory :as factory]
            [cheshire.generate :as gen]
            [cheshire.generate-seq :as gen-seq]
            [cheshire.parse :as parse])
  (:import (com.fasterxml.jackson.core JsonParser JsonFactory
                                       JsonGenerator PrettyPrinter
                                       JsonGenerator$Feature)
           (com.fasterxml.jackson.dataformat.cbor CBORFactory)
           (com.fasterxml.jackson.dataformat.smile SmileFactory)
           (cheshire.prettyprint CustomPrettyPrinter)
           (java.io StringWriter StringReader BufferedReader BufferedWriter
                    ByteArrayOutputStream OutputStream Reader Writer)))

;; Automatically added requires by core.typed
(require '[clojure.core.typed :as t])
;; Start: Generated by clojure.core.typed - DO NOT EDIT
(declare
  AfterArrayValuesBeforeArrayValuesDateFormatMap
  BazMap
  Foo bazMap
  FooBarQuuxMap
  MootMap
  UluMap
  alias__10142
  alias__10248
  alias__10250
  alias__9764
  alias__9766
  alias__9865
  alias__9870
  alias__9882)
(t/defalias
  AfterArrayValuesBeforeArrayValuesDateFormatMap
  (t/HMap
    :optional
    {:after-array-values t/Str,
     :before-array-values t/Str,
     :date-format t/Str,
     :escape-non-ascii Boolean,
     :indent-arrays? false,
     :indent-objects? false,
     :indentation t/Int,
     :key-fn [':foo :-> t/Str],
     :object-field-value-separator t/Str,
     :pretty (t/U alias__9882 alias__10142)}))
(t/defalias BazMap '{:baz (t/U '[UluMap MootMap t/Int] t/Int)})
(t/defalias Foo bazMap '{:foo baz t/Str})
(t/defalias
  FooBarQuuxMap
  (t/HMap
    :mandatory
    {:foo (t/U t/Str java.util.Date t/Int java.sql.Timestamp ':bar)}
    :optional
    {:quux ':blub, :bar (t/U t/Int alias__9865)}))
(t/defalias MootMap '{:moot t/Str})
(t/defalias UluMap '{:ulu t/Str})
(t/defalias
  alias__10142
  (t/U
    nil
    AfterArrayValuesBeforeArrayValuesDateFormatMap
    Boolean
    (t/Map t/Nothing t/Nothing)
    (t/Vec t/Nothing)))
(t/defalias alias__10248 (t/U (t/Set t/Nothing) (t/Vec t/Nothing)))
(t/defalias alias__10250 (t/U (t/Set t/Nothing) (t/Vec t/Nothing)))
(t/defalias alias__9764 (t/U (t/Set t/Nothing) (t/Vec t/Nothing)))
(t/defalias alias__9766 (t/U (t/Set t/Nothing) (t/Vec t/Nothing)))
(t/defalias
  alias__9865
  (t/U '[alias__9865 ':quux '[t/Int t/Int t/Int]] BazMap))
(t/defalias alias__9870 (t/U FooBarQuuxMap '[alias__9870 alias__9870]))
(t/defalias
  alias__9882
  (t/U
    nil
    AfterArrayValuesBeforeArrayValuesDateFormatMap
    Boolean
    (t/Map t/Nothing t/Nothing)
    (t/Vec t/Nothing)))
(t/ann
  create-generator
  [StringWriter
   :->
   com.fasterxml.jackson.core.json.WriterBasedJsonGenerator])
(t/ann
  create-pretty-printer
  [AfterArrayValuesBeforeArrayValuesDateFormatMap
   :->
   CustomPrettyPrinter])
(t/ann
  decode
  (t/IFn
    [t/Str
     false
     [t/Str :-> (t/U (t/Set t/Nothing) (t/Vec t/Nothing))]
     :->
     (t/Map
       t/Any
       (t/U '[t/Str t/Str] (t/Map t/Any t/Int) (t/Set t/Str)))]
    [t/Str :-> t/Any]
    [(t/U nil t/Str)
     (t/U nil [t/Str :-> ':FOO] [t/Any :-> ':FOO] Boolean)
     :->
     t/Any]))
(t/ann decode-smile AnyFunction)
(t/ann decode-stream AnyFunction)
(t/ann decode-strict [t/Str :-> (t/Map t/Any t/Int)])
(t/ann
  encode
  (t/IFn
    [alias__9870
     AfterArrayValuesBeforeArrayValuesDateFormatMap
     :->
     t/Str]
    [(t/U
       java.util.ArrayList
       cheshire.test.core.CTestR
       java.net.URL
       (t/Coll t/Any)
       cheshire.test.core.TestR
       t/Num
       java.util.HashMap
       (t/Map t/Any t/Any))
     :->
     t/Str]))
(t/ann encode-smile AnyFunction)
(t/ann encode-stream AnyFunction)
(t/ann eof Object)
(t/ann generate-cbor AnyFunction)
(t/ann
  generate-smile
  (t/IFn
    [(t/Map t/Any t/Any) nil :-> (Array byte)]
    [(t/Map t/Any t/Any) :-> (Array byte)]))
(t/ann
  generate-stream
  (t/IFn
    [(t/Map t/Any t/Str) BufferedWriter nil :-> BufferedWriter]
    [(t/Map t/Any t/Str) BufferedWriter :-> BufferedWriter]))
(t/ann
  generate-string
  (t/IFn
    [(t/U
       java.util.ArrayList
       cheshire.test.core.CTestR
       java.net.URL
       (t/Coll t/Any)
       cheshire.test.core.TestR
       t/Num
       java.util.HashMap
       (t/Map t/Any t/Any))
     (t/U nil AfterArrayValuesBeforeArrayValuesDateFormatMap)
     :->
     t/Str]
    [(t/U
       java.util.ArrayList
       cheshire.test.core.CTestR
       java.net.URL
       (t/Coll t/Any)
       cheshire.test.core.TestR
       t/Num
       java.util.HashMap
       (t/Map t/Any t/Any))
     :->
     t/Str]))
(t/ann parse-cbor AnyFunction)
(t/ann
  parse-smile
  (t/IFn
    [(Array byte) nil nil :-> (t/Map t/Any t/Any)]
    [(Array byte) :-> (t/Map t/Any t/Any)]))
(t/ann
  parse-stream
  (t/IFn
    [StringReader Boolean :-> Foo bazMap]
    [(t/U BufferedReader StringReader)
     (t/U nil Boolean)
     nil
     :->
     (t/Map t/Any t/Str)]
    [BufferedReader :-> (t/Map t/Any t/Str)]))
(t/ann
  parse-string
  (t/IFn
    [(t/U nil t/Str)
     (t/U nil [t/Str :-> ':FOO] [t/Any :-> ':FOO] Boolean)
     (t/U
       nil
       [t/Str :-> alias__10248]
       [t/Str :-> (t/U alias__10250 alias__10248)])
     :->
     t/Any]
    [t/Str :-> t/Any]
    [(t/U nil t/Str)
     (t/U nil [t/Str :-> ':FOO] [t/Any :-> ':FOO] Boolean)
     :->
     t/Any]))
(t/ann
  parse-string-strict
  (t/IFn
    [t/Str nil nil :-> (t/Map t/Any t/Int)]
    [t/Str :-> (t/Map t/Any t/Int)]))
(t/ann
  parsed-seq
  (t/IFn
    [BufferedReader
     nil
     nil
     :->
     (t/Coll (t/U t/Int (t/Map t/Any (t/U t/Str t/Int))))]
    [BufferedReader
     :->
     (t/Coll (t/U t/Int (t/Map t/Any (t/U t/Str t/Int))))]))
(t/ann
  parsed-seq*
  [com.fasterxml.jackson.core.json.ReaderBasedJsonParser
   nil
   nil
   :->
   (t/Coll (t/U t/Int (t/Map t/Any (t/U t/Str t/Int))))])
(t/ann parsed-smile-seq AnyFunction)
(t/ann
  write
  (t/IFn
    [(t/U t/Str t/Int '[t/Str]) :-> nil]
    [t/Any (t/U nil ':end ':all ':start-inner ':bare ':start) :-> nil]))
(t/ann cheshire.factory/*json-factory* (t/U nil JsonFactory))
(t/ann cheshire.factory/*smile-factory* nil)
(t/ann cheshire.factory/default-date-format t/Str)
(t/ann cheshire.factory/json-factory JsonFactory)
(t/ann cheshire.factory/smile-factory SmileFactory)
(t/ann
  cheshire.generate/generate
  [(t/U
     com.fasterxml.jackson.core.json.WriterBasedJsonGenerator
     com.fasterxml.jackson.dataformat.smile.SmileGenerator)
   (t/U
     java.util.ArrayList
     cheshire.test.core.CTestR
     java.net.URL
     (t/Coll t/Any)
     cheshire.test.core.TestR
     t/Num
     java.util.HashMap
     (t/Map t/Any t/Any))
   t/Str
   nil
   (t/U nil [':foo :-> t/Str])
   :->
   nil])
(t/ann
  cheshire.generate-seq/generate
  [com.fasterxml.jackson.core.json.WriterBasedJsonGenerator
   t/Any
   t/Str
   nil
   nil
   ':wholeness
   (t/U nil ':end ':all ':start-inner ':bare ':start)
   :->
   nil])
(t/ann
  cheshire.parse/parse
  [(t/U
     com.fasterxml.jackson.dataformat.smile.SmileParser
     com.fasterxml.jackson.core.json.ReaderBasedJsonParser)
   (t/U nil [t/Str :-> ':FOO] [t/Any :-> ':FOO] Boolean)
   nil
   (t/U
     nil
     [t/Str :-> (t/U alias__9764 alias__9766)]
     [t/Any :-> alias__9766])
   :->
   t/Any])
(t/ann
  cheshire.parse/parse-strict
  [com.fasterxml.jackson.core.json.ReaderBasedJsonParser
   nil
   (t/U nil Object)
   nil
   :->
   (t/U Object t/Int (t/Map t/Any (t/U t/Str t/Int)))])
;; End: Generated by clojure.core.typed - DO NOT EDIT
(defonce default-pretty-print-options
  {:indentation "  "
   :line-break "\n"
   :indent-arrays? false
   :indent-objects? true
   :before-array-values nil
   :after-array-values nil
   :object-field-value-separator nil})

(defn create-pretty-printer
  "Returns an instance of CustomPrettyPrinter based on the configuration
  provided as argument"
  [options]
  (let [effective-opts (merge default-pretty-print-options options)
        indentation (:indentation effective-opts)
        line-break (:line-break effective-opts)
        indent-arrays? (:indent-arrays? effective-opts)
        indent-objects? (:indent-objects? effective-opts)
        before-array-values (:before-array-values effective-opts)
        after-array-values (:after-array-values effective-opts)
        object-field-value-separator (:object-field-value-separator effective-opts)
        indent-with (condp instance? indentation
                      String indentation
                      Long (apply str (repeat indentation " "))
                      Integer (apply str (repeat indentation " "))
                      "  ")]
    (-> (new CustomPrettyPrinter)
        (.setIndentation indent-with line-break indent-objects? indent-arrays?)
        (.setBeforeArrayValues before-array-values)
        (.setAfterArrayValues after-array-values)
        (.setObjectFieldValueSeparator object-field-value-separator))))

;; Generators
(defn generate-string
  "Returns a JSON-encoding String for the given Clojure object. Takes an
  optional date format string that Date objects will be encoded with.

  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'"
  (^String [obj]
   (generate-string obj nil))
  (^String [obj opt-map]
   (let [sw (StringWriter.)
         generator (.createGenerator
                    ^JsonFactory (or factory/*json-factory*
                                     factory/json-factory)
                    ^Writer sw)
         print-pretty (:pretty opt-map)]
     (when print-pretty
       (condp instance? print-pretty
         Boolean
           (.useDefaultPrettyPrinter generator)
         clojure.lang.IPersistentMap
           (.setPrettyPrinter generator (create-pretty-printer print-pretty))
         PrettyPrinter
           (.setPrettyPrinter generator print-pretty)
         nil))
     (when (:escape-non-ascii opt-map)
       (.enable generator JsonGenerator$Feature/ESCAPE_NON_ASCII))
     (gen/generate generator obj
                   (or (:date-format opt-map) factory/default-date-format)
                   (:ex opt-map)
                   (:key-fn opt-map))
     (.flush generator)
     (.toString sw))))

(defn generate-stream
  "Returns a BufferedWriter for the given Clojure object with the JSON-encoded
  data written to the writer. Takes an optional date format string that Date
  objects will be encoded with.

  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'"
  (^BufferedWriter [obj ^BufferedWriter writer]
   (generate-stream obj writer nil))
  (^BufferedWriter [obj ^BufferedWriter writer opt-map]
   (let [generator (.createGenerator
                    ^JsonFactory (or factory/*json-factory*
                                     factory/json-factory)
                    ^Writer writer)
         print-pretty (:pretty opt-map)]
     (when print-pretty
       (condp instance? print-pretty
         Boolean
       (.useDefaultPrettyPrinter generator)
         clojure.lang.IPersistentMap
       (.setPrettyPrinter generator (create-pretty-printer print-pretty))
         PrettyPrinter
       (.setPrettyPrinter generator print-pretty)
         nil))
     (when (:escape-non-ascii opt-map)
       (.enable generator JsonGenerator$Feature/ESCAPE_NON_ASCII))
     (gen/generate generator obj (or (:date-format opt-map)
                                     factory/default-date-format)
                   (:ex opt-map)
                   (:key-fn opt-map))
     (.flush generator)
     writer)))

(defn create-generator [writer]
  "Returns JsonGenerator for given writer."
  (.createGenerator
   ^JsonFactory (or factory/*json-factory*
                    factory/json-factory)
   ^Writer writer))

(def ^:dynamic ^JsonGenerator *generator*)
(def ^:dynamic *opt-map*)

(defmacro with-writer [[writer opt-map] & body]
  "Start writing for series objects using the same json generator.
   Takes writer and options map as arguments.
   Expects its body as sequence of write calls.
   Returns a given writer."
  `(let [c-wr# ~writer]
     (binding [*generator* (create-generator c-wr#)
               *opt-map* ~opt-map]
       ~@body
       (.flush *generator*)
       c-wr#)))

(defn write
  "Write given Clojure object as a piece of data within with-writer.
  List of wholeness acceptable values:
  - no value - the same as :all
  - :all - write object in a regular way with start and end borders
  - :start - write object with start border only
  - :start-inner - write object and its inner object with start border only
  - :end - write object with end border only."
  ([obj] (write obj nil))
  ([obj wholeness]
   (gen-seq/generate *generator* obj (or (:date-format *opt-map*)
                                         factory/default-date-format)
                     (:ex *opt-map*)
                     (:key-fn *opt-map*)
                     :wholeness wholeness)))

(defn generate-smile
  "Returns a SMILE-encoded byte-array for the given Clojure object.
  Takes an optional date format string that Date objects will be encoded with.

  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'"
  (^bytes [obj]
   (generate-smile obj nil))
  (^bytes [obj opt-map]
   (let [baos (ByteArrayOutputStream.)
         generator (.createGenerator ^SmileFactory
                                     (or factory/*smile-factory*
                                         factory/smile-factory)
                                     ^OutputStream baos)]
     (gen/generate generator obj (or (:date-format opt-map)
                                     factory/default-date-format)
                   (:ex opt-map)
                   (:key-fn opt-map))
     (.flush generator)
     (.toByteArray baos))))

(defn generate-cbor
  "Returns a CBOR-encoded byte-array for the given Clojure object.
  Takes an optional date format string that Date objects will be encoded with.

  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'"
  (^bytes [obj]
   (generate-cbor obj nil))
  (^bytes [obj opt-map]
   (let [baos (ByteArrayOutputStream.)
         generator (.createGenerator ^CBORFactory
                                     (or factory/*cbor-factory*
                                         factory/cbor-factory)
                                     ^OutputStream baos)]
     (gen/generate generator obj (or (:date-format opt-map)
                                     factory/default-date-format)
                   (:ex opt-map)
                   (:key-fn opt-map))
     (.flush generator)
     (.toByteArray baos))))

;; Parsers
(defn parse-string
  "Returns the Clojure object corresponding to the given JSON-encoded string.
  An optional key-fn argument can be either true (to coerce keys to keywords),
  false to leave them as strings, or a function to provide custom coercion.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values.

  If the top-level object is an array, it will be parsed lazily (use
  `parse-strict' if strict parsing is required for top-level arrays."
  ([string] (parse-string string nil nil))
  ([string key-fn] (parse-string string key-fn nil))
  ([^String string key-fn array-coerce-fn]
   (when string
     (parse/parse
      (.createParser ^JsonFactory (or factory/*json-factory*
                                      factory/json-factory)
                     ^Reader (StringReader. string))
      key-fn nil array-coerce-fn))))

;; Parsing strictly
(defn parse-string-strict
  "Returns the Clojure object corresponding to the given JSON-encoded string.
  An optional key-fn argument can be either true (to coerce keys to keywords),
  false to leave them as strings, or a function to provide custom coercion.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values.

  Does not lazily parse top-level arrays."
  ([string] (parse-string-strict string nil nil))
  ([string key-fn] (parse-string-strict string key-fn nil))
  ([^String string key-fn array-coerce-fn]
   (when string
     (parse/parse-strict
      (.createParser ^JsonFactory (or factory/*json-factory*
                                      factory/json-factory)
                     ^Writer (StringReader. string))
      key-fn nil array-coerce-fn))))

(defn parse-stream
  "Returns the Clojure object corresponding to the given reader, reader must
  implement BufferedReader. An optional key-fn argument can be either true (to
  coerce keys to keywords),false to leave them as strings, or a function to
  provide custom coercion.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values.

  If the top-level object is an array, it will be parsed lazily (use
  `parse-strict' if strict parsing is required for top-level arrays.

  If multiple objects (enclosed in a top-level `{}' need to be parsed lazily,
  see parsed-seq."
  ([rdr] (parse-stream rdr nil nil))
  ([rdr key-fn] (parse-stream rdr key-fn nil))
  ([^BufferedReader rdr key-fn array-coerce-fn]
   (when rdr
     (parse/parse
      (.createParser ^JsonFactory (or factory/*json-factory*
                                      factory/json-factory)
                     ^Reader rdr)
      key-fn nil array-coerce-fn))))

(defn parse-smile
  "Returns the Clojure object corresponding to the given SMILE-encoded bytes.
  An optional key-fn argument can be either true (to coerce keys to keywords),
  false to leave them as strings, or a function to provide custom coercion.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values."
  ([bytes] (parse-smile bytes nil nil))
  ([bytes key-fn] (parse-smile bytes key-fn nil))
  ([^bytes bytes key-fn array-coerce-fn]
   (when bytes
     (parse/parse
      (.createParser ^SmileFactory (or factory/*smile-factory*
                                       factory/smile-factory) bytes)
      key-fn nil array-coerce-fn))))

(defn parse-cbor
  "Returns the Clojure object corresponding to the given CBOR-encoded bytes.
  An optional key-fn argument can be either true (to coerce keys to keywords),
  false to leave them as strings, or a function to provide custom coercion.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values."
  ([bytes] (parse-cbor bytes nil nil))
  ([bytes key-fn] (parse-cbor bytes key-fn nil))
  ([^bytes bytes key-fn array-coerce-fn]
   (when bytes
     (parse/parse
      (.createParser ^CBORFactory (or factory/*cbor-factory*
                                      factory/cbor-factory) bytes)
      key-fn nil array-coerce-fn))))

(def ^{:doc "Object used to determine end of lazy parsing attempt."}
  eof (Object.))

;; Lazy parsers
(defn- parsed-seq*
  "Internal lazy-seq parser"
  [^JsonParser parser key-fn array-coerce-fn]
  (lazy-seq
   (let [elem (parse/parse-strict parser key-fn eof array-coerce-fn)]
     (when-not (identical? elem eof)
       (cons elem (parsed-seq* parser key-fn array-coerce-fn))))))

(defn parsed-seq
  "Returns a lazy seq of Clojure objects corresponding to the JSON read from
  the given reader. The seq continues until the end of the reader is reached.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values.
  If non-laziness is needed, see parse-stream."
  ([reader] (parsed-seq reader nil nil))
  ([reader key-fn] (parsed-seq reader key-fn nil))
  ([^BufferedReader reader key-fn array-coerce-fn]
   (when reader
     (parsed-seq* (.createParser ^JsonFactory
                                 (or factory/*json-factory*
                                     factory/json-factory)
                                 ^Reader reader)
                  key-fn array-coerce-fn))))

(defn parsed-smile-seq
  "Returns a lazy seq of Clojure objects corresponding to the SMILE read from
  the given reader. The seq continues until the end of the reader is reached.

  The array-coerce-fn is an optional function taking the name of an array field,
  and returning the collection to be used for array values."
  ([reader] (parsed-smile-seq reader nil nil))
  ([reader key-fn] (parsed-smile-seq reader key-fn nil))
  ([^BufferedReader reader key-fn array-coerce-fn]
   (when reader
     (parsed-seq* (.createParser ^SmileFactory
                                 (or factory/*smile-factory*
                                     factory/smile-factory)
                                 ^Reader reader)
                  key-fn array-coerce-fn))))

;; aliases for clojure-json users
(defmacro copy-arglists
  [dst src]
  `(alter-meta! (var ~dst) merge (select-keys (meta (var ~src)) [:arglists])))
(def encode "Alias to generate-string for clojure-json users" generate-string)
(copy-arglists encode generate-string)
(def encode-stream "Alias to generate-stream for clojure-json users" generate-stream)
(copy-arglists encode-stream generate-stream)
(def encode-smile "Alias to generate-smile for clojure-json users" generate-smile)
(copy-arglists encode-smile generate-smile)
(def decode "Alias to parse-string for clojure-json users" parse-string)
(copy-arglists decode parse-string)
(def decode-strict "Alias to parse-string-strict for clojure-json users" parse-string-strict)
(copy-arglists decode-strict parse-string-strict)
(def decode-stream "Alias to parse-stream for clojure-json users" parse-stream)
(copy-arglists decode-stream parse-stream)
(def decode-smile "Alias to parse-smile for clojure-json users" parse-smile)
(copy-arglists decode-smile parse-smile)